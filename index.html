<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="pandoc.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Here are contained a few toy examples of how powerful abstracting over contexts can be in real-life situations. Well, at least as &quot;real-life&quot; as high-energy physics is. I'm not going to discuss haskell syntax carefully here, and I will leave out many details (e.g. the rigorous definition of <code class="sourceCode haskell"><span class="dt">Monad</span></code>s). All the same, this tutorial will hopefully convince you that there is something to be gained by moving to a more mathematically rigorous representation of analysis procedures, even if it's a slightly more abstract one than we usually deal with in traditional programming languages. (This is exactly what source code is, after all: a representation of a mathematical procedure, and often quite a poor one.)</p>
<p>Don't worry if not everything makes sense immediately: these aren't easy concepts to grasp the first time through. This file is written in literate haskell, so you should be able to copy-and-paste the text into a local file (e.g. <code>HEPExample.lhs</code>) and load it into the haskell REPL, <code>ghci</code>, like so.</p>
<pre><code>$ ghci HEPExample.lhs</code></pre>
<p>Any lines beginning with bird &quot;HEPExample&gt;&quot; can be called from within the REPL. (N.B.: you'll need to install the <code>transformers</code>, <code>primitive</code>, and <code>mwc-probability</code> packages in addition to the base libraries, but I'll let google be your friend for how to do that).</p>
<p>Let's start with a module declaration and some imports.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">HEPExample</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Control.Monad.Trans.Maybe</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.Functor.Identity</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.Monoid</span>                   (<span class="dt">Product</span> (..))
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">System.Random.MWC.Probability</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Control.Monad.Primitive</span></code></pre></div>
<p>Then let's define an <code class="sourceCode haskell"><span class="dt">Event</span></code> data type which contains only two pieces of information: an electron pt and a muon pt.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Event&#39;</span> <span class="fu">=</span> <span class="dt">Event&#39;</span> {<span class="ot"> elPt&#39; ::</span> <span class="dt">Double</span>,<span class="ot"> muPt&#39; ::</span> <span class="dt">Double</span> }
<span class="ot">&gt;</span> 
<span class="ot">&gt; evt&#39; ::</span> <span class="dt">Event&#39;</span>
<span class="ot">&gt;</span> evt&#39; <span class="fu">=</span> <span class="dt">Event&#39;</span> <span class="fl">25.5</span> <span class="fl">54.2</span></code></pre></div>
<p>Great! Now we have a new data type (<code class="sourceCode haskell"><span class="dt">Event&#39;</span></code>) as well as an value inhabiting it called <code class="sourceCode haskell">evt&#39;</code>; hopefully this is straightforward so far. If you could read the future you would know that I call this data type <code class="sourceCode haskell"><span class="dt">Event&#39;</span></code> (emphasis on the prime) as opposed to <code class="sourceCode haskell"><span class="dt">Event</span></code> because we'll shortly be making everything a <em>heck of a lot</em> fancier. But let's walk before we run, shall we?</p>
<p>Next we define a function that takes as input an <code class="sourceCode haskell"><span class="dt">Event&#39;</span></code> and returns an observable: the pt sum of the two leptons in the event.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sumPt&#39; ::</span> <span class="dt">Event&#39;</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
<span class="ot">&gt;</span> sumPt&#39; evt <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="kw">let</span> ept <span class="fu">=</span> elPt&#39; evt
<span class="ot">&gt;</span>       mpt <span class="fu">=</span> muPt&#39; evt
<span class="ot">&gt;</span>   <span class="kw">in</span> ept <span class="fu">+</span> mpt</code></pre></div>
<p>Capisce? If you've loaded this file into <code>ghci</code>, you can check that things work properly:</p>
<pre><code>HEPExample&gt; sumPt&#39; evt&#39;
77.9</code></pre>
<p>By my calculation that's exactly the answer we expect. So far so good? I'll assume yes.</p>
<p>Now let's make things more interesting: I want my <code class="sourceCode haskell"><span class="dt">Event</span></code> type to return some kind of <em>context</em> around the lepton pts. And by &quot;context&quot; I mean that there is some decoration or container that my pt lives in: perhaps there is a list of pts or it is always accompanied by some additional information. Thankfully, we don't have to be specific to start: we can <em>parameterize</em> our <code class="sourceCode haskell"><span class="dt">Event</span></code> type by the context that we will (in the future) be using. Why do now what could be done tomorrow?</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Event</span> m <span class="fu">=</span> <span class="dt">Event</span> {<span class="ot"> elPt ::</span> m <span class="dt">Double</span>,<span class="ot"> muPt ::</span> m <span class="dt">Double</span> }</code></pre></div>
<p>For you non-procrasinators, don't worry: we'll have some examples that are conspicuous in high energy physics soon.</p>
<p>ok, so at this point let's think about what kind of thing <code class="sourceCode haskell">m</code> must be: <code class="sourceCode haskell">m</code> actually takes <code class="sourceCode haskell"><span class="dt">Double</span></code> as an <em>argument</em>, so it looks like it could be a decoration or container around <code class="sourceCode haskell"><span class="dt">Double</span></code>, i.e. a context in which the <code class="sourceCode haskell"><span class="dt">Double</span></code>s live. Let's do something <em>silly</em> (and yet surprisingly powerful) to give ourselves a concrete example: let's use a trivial context, a container that just holds onto the original value and does nothing else. In haskell this is called the <code class="sourceCode haskell"><span class="dt">Identity</span></code> type, and it has only one constructor, also called <code class="sourceCode haskell"><span class="dt">Identity</span></code>, which is nothing more than a wrapper that contains a value. We can easily make an <code class="sourceCode haskell"><span class="dt">Event</span></code> with a trivial context:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; evtId ::</span> <span class="dt">Event</span> <span class="dt">Identity</span>
<span class="ot">&gt;</span> evtId <span class="fu">=</span> <span class="dt">Event</span> (<span class="dt">Identity</span> <span class="fl">25.5</span>) (<span class="dt">Identity</span> <span class="fl">54.2</span>)</code></pre></div>
<p>The discerning reader will realize that this is isomorphic to the simple <code class="sourceCode haskell">evt&#39;</code> we originally defined above: there's no new information added or removed by the <code class="sourceCode haskell"><span class="dt">Identity</span></code> constructors. To the discerning reader I say, &quot;Trust me: this is a baby step, but a baby step in the right direction!&quot;</p>
<p>So far we've (trivially) complicated our <code class="sourceCode haskell"><span class="dt">Event&#39;</span></code> type; let's go further and complicate the <code class="sourceCode haskell">sumPt&#39;</code> function. One common way to <em>lift</em> a &quot;regular&quot; function like <code class="sourceCode haskell">sumPt&#39;</code> to a &quot;contextified&quot; function is to use haskell's <code class="sourceCode haskell"><span class="kw">do</span></code>-notation. In the end this is really just syntactic sugar, but like many things in the haskell world, it's well-motivated by some quite nice (if quite abstract) mathematics. One rule of thumb to perform this function <em>lifting</em> is to replace <code class="sourceCode haskell"><span class="kw">let</span></code> bindings by &quot;monadic assignments&quot; (I put this in quotes because I don't like the word &quot;assignment&quot; very much, but I can't think of anything better) and make sure to <code class="sourceCode haskell">return</code> the final value, like so:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sumPt ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Event</span> m <span class="ot">-&gt;</span> m <span class="dt">Double</span>
<span class="ot">&gt;</span> sumPt evt <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   ept <span class="ot">&lt;-</span> elPt evt    <span class="co">-- monadic assignment</span>
<span class="ot">&gt;</span>   mpt <span class="ot">&lt;-</span> muPt evt    <span class="co">-- monadic assignment</span>
<span class="ot">&gt;</span>   return (ept <span class="fu">+</span> mpt) <span class="co">-- return</span></code></pre></div>
<p>Do you see how the <code class="sourceCode haskell"><span class="kw">do</span></code>-notation makes our new, fancy function resemble our original, simple function quite closely? Try it:</p>
<pre><code>HEPExample&gt; sumPt evtId
Identity 77.9</code></pre>
<p>That yields (effectively) the same answer that we got earlier, which is good because we know we didn't add or remove any information at all. Great, we successfully did nothing! Sarcasm aside, what is really going on here...?</p>
<p>Here's one way to think about it: each line in the <code class="sourceCode haskell"><span class="kw">do</span></code> block yields both a value and a context, but only the <em>value</em> is bound to a variable (e.g. <code class="sourceCode haskell">ept</code>): we don't have a handle on the contexts at all. But the only way this works is if we have a <em>context</em> that is <em>composable</em> line-by-line. Well, that's exactly what the <code class="sourceCode haskell"><span class="dt">Monad</span></code> type constraint is telling us in the type signature of <code class="sourceCode haskell">sumPt</code>: a <code class="sourceCode haskell"><span class="dt">Monad</span></code> in plain terms is a context that composes (along with some &quot;obvious&quot; laws that we'll leave for a rainy day). With this one function we can use <em>any</em> context that follows the <code class="sourceCode haskell"><span class="dt">Monad</span></code> laws.</p>
<p>What's especially clever about this setup is that we've entirely <em>abstracted away</em> the type of the context. In other words, we no longer can perform any actions in our function that are dependent on a particular context <code class="sourceCode haskell">m</code>; we can only perform actions that <em>any</em> composable context can handle. How is this powerful? Well, it means that we have to tell the compiler how each particular context conforms to the <code class="sourceCode haskell"><span class="dt">Monad</span></code> type class <em>exactly once</em>; from there we can pass our context into any suitable function and the compiler <em>does the composition for us</em>: there's really no way for us to mess up the composing because we aren't handling it at all. And you'd be surprised how many contexts meet these requirements and can therefore be fed into this single function!</p>
<p>For example, let's think about the case that perhaps we're missing an electron or muon from our <code class="sourceCode haskell"><span class="dt">Event</span></code>; maybe we failed to reconstruct one of them, or there weren't even any candidates at all. This &quot;perhaps we have something, perhaps not&quot; kind of data is generally encoded by the <code class="sourceCode haskell"><span class="dt">Maybe</span></code> type in haskell. It has two constructors: <code class="sourceCode haskell"><span class="dt">Just</span></code> and <code class="sourceCode haskell"><span class="dt">Nothing</span></code>. If we have a value x, then the value-with-context will be <code class="sourceCode haskell"><span class="dt">Just</span> x</code>; if the value is missing, then we have <code class="sourceCode haskell"><span class="dt">Nothing</span></code>. Some people say that you can think of <code class="sourceCode haskell"><span class="dt">Nothing</span></code> as similar to a <code>NULL</code> pointer in C++ or <code>None</code> in python, but I disagree: <code class="sourceCode haskell"><span class="dt">Nothing</span></code> always has a concrete type <code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>, where <code class="sourceCode haskell">a</code> is a type parameter. So <code class="sourceCode haskell"><span class="dt">Nothing</span></code> of type <code class="sourceCode haskell"><span class="dt">Maybe</span> <span class="dt">Int</span></code> is <em>distinct from</em> <code class="sourceCode haskell"><span class="dt">Nothing</span></code> of type <code class="sourceCode haskell"><span class="dt">Maybe</span> <span class="dt">Double</span></code>; <code>NULL</code> and <code>None</code> can be compared to <em>any</em> pointer or object, respectively, regardless of their types. This might seem tedious at first, but it allows us (and the compiler) to more clearly reason about what a computation is doing.</p>
<p>ok, let's try defining some <code class="sourceCode haskell"><span class="dt">Event</span></code>s that might be missing some leptons.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> evtElMu, evtElNoMu,<span class="ot"> evtNoElMu ::</span> <span class="dt">Event</span> <span class="dt">Maybe</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> evtElMu <span class="fu">=</span> <span class="dt">Event</span> (<span class="dt">Just</span> <span class="fl">25.5</span>) (<span class="dt">Just</span> <span class="fl">54.2</span>) <span class="co">-- both electron and muon identified</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> evtElNoMu <span class="fu">=</span> <span class="dt">Event</span> (<span class="dt">Just</span> <span class="fl">25.5</span>) <span class="dt">Nothing</span>   <span class="co">-- missing a muon</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> evtNoElMu <span class="fu">=</span> <span class="dt">Event</span> <span class="dt">Nothing</span> (<span class="dt">Just</span> <span class="fl">54.2</span>)   <span class="co">-- missing an electron</span></code></pre></div>
<p>What's really great about <code class="sourceCode haskell"><span class="dt">Maybe</span></code> is that it is a <em>composable context</em>, so we can use it in our generic monadic code! How do <code class="sourceCode haskell"><span class="dt">Maybe</span></code>s compose? Well, if we try to compose two <code class="sourceCode haskell"><span class="dt">Just</span></code>s, then we get yet another <code class="sourceCode haskell"><span class="dt">Just</span></code>; if there are any <code class="sourceCode haskell"><span class="dt">Nothing</span></code>s involoved, the combination always yields a <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</p>
<p>Try it out:</p>
<pre><code>HEPExample&gt; sumPt evtElMu
Just 79.7

HEPExample&gt; sumPt evtElNoMu
Nothing

HEPExample&gt; sumPt evtNoElMu
Nothing</code></pre>
<p>What happened here? Well, if we have both an electron and a muon, that's great: we have a well-defined <code class="sourceCode haskell">sumPt</code>. If we're missing either input to the <code class="sourceCode haskell">sumPt</code> calculation, though, well... we can't do the calculation, so we get <code class="sourceCode haskell"><span class="dt">Nothing</span></code> back. Now <em>some</em> people might ask, &quot;why don't I just use a default value in this situation?&quot; I'll let you think carefully about that one and come up with your own reasons as to why default values are, in general, a Really Bad Idea.</p>
<p>Shall we try another context? How about this: let's take on &quot;scale factors&quot;. What if our <code class="sourceCode haskell"><span class="dt">Event</span></code>'s electron and muon each come with some scale factor that ought to be taken into account? Well, this is clearly just another context: each value carries along with it an extra <code class="sourceCode haskell"><span class="dt">Double</span></code>, and these <code class="sourceCode haskell"><span class="dt">Double</span></code>s are <em>multiplicative factors</em>, i.e. to compose the contexts we multiply the scale factors. We've just defined (broken record alert) yet another composable context that we can plug into our <code class="sourceCode haskell">sumPt</code> function. And by black magic all of this already lives in the haskell <code>base</code> libraries.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">SF</span> <span class="fu">=</span> <span class="dt">Product</span> <span class="dt">Double</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; evtSF ::</span> <span class="dt">Event</span> ((,) <span class="dt">SF</span>)
<span class="ot">&gt;</span> evtSF <span class="fu">=</span> <span class="dt">Event</span> (<span class="dt">Product</span> <span class="fl">1.1</span>, <span class="fl">25.5</span>) (<span class="dt">Product</span> <span class="fl">0.93</span>, <span class="fl">54.2</span>)</code></pre></div>
<p>If that's not 100% clear, <code class="sourceCode haskell">evtSF</code> is an <code class="sourceCode haskell"><span class="dt">Event</span></code> whose electrons and muons have some scale factor associated to them: we now have a context of type</p>
<pre><code>(,) SF</code></pre>
<p>which translates into a 2-tuple in which the first object is always a scale factor (in haskell <code class="sourceCode haskell">(x, y)</code> is just syntactic sugar for the tuple constructor <code class="sourceCode haskell">(,) x y</code>).</p>
<p>The <code class="sourceCode haskell"><span class="dt">SF</span></code> type (actually the type-aliased <code class="sourceCode haskell"><span class="dt">Product</span> <span class="dt">Double</span></code> type) already knows how to correctly <em>combine</em> with itself: multiplication! &quot;But why is this necessary? Why can't I just use regular old Doubles for my scale factors&quot;, you ask. Well, because the real numbers have many ways of combining with each another: addition, multiplication, etc.; we need to be sure that when we combine them, they always multiply and not one of those many other things. Let's try this out.</p>
<pre><code>HEPExample&gt; sumPt evtSF
(Product {getProduct = 1.0230000000000001},79.7)</code></pre>
<p><em>SeemsGood</em>. In fact, what's <em>really</em> great about this is that there is never any question as to which scale factors apply to the calculation of an observable.</p>
<pre><code>HEPExample&gt; elPt evtSF
(Product {getProduct = 1.1},25.5)</code></pre>
<p>The <code class="sourceCode haskell">elPt</code> function only accesses the information relevant to the electron in the event, so only the electron scale factor plays a role in the output because, again, the scale factor here is just a context that is automatically propagated through the computation.</p>
<p>ok, one more example to go (if you're still with me)... It turns out that probability distributions form another valid, composable context, and a very useful one at that.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; evtProb ::</span> <span class="dt">PrimMonad</span> m <span class="ot">=&gt;</span> <span class="dt">Event</span> (<span class="dt">Prob</span> m)
<span class="ot">&gt;</span> evtProb <span class="fu">=</span> <span class="dt">Event</span> (normal <span class="fl">25.5</span> <span class="fl">4.3</span>) (normal <span class="fl">54.2</span> <span class="fl">11.9</span>)</code></pre></div>
<p>The above defines an event that, instead of having particular values for the electron and muon pts, holds probability distributions for each of them. In this case the electron (muon) pt is normally distributed around a mean of 25.5 (54.2) and standard deviation of 4.3 (11.9).</p>
<p>(For now we'll not discuss the idea behind the <code class="sourceCode haskell"><span class="dt">PrimMonad</span></code> type class; just trust me when I say that the <code class="sourceCode haskell"><span class="dt">Prob</span> m a</code> type represents probability densities as a function of values of type <code class="sourceCode haskell">a</code>. So <code class="sourceCode haskell"><span class="dt">Prob</span> m <span class="dt">Int</span></code> means each <code class="sourceCode haskell"><span class="dt">Int</span></code> has a probability assigned to it.)</p>
<p>ok, let's give this a whirl:</p>
<pre><code>HEPExample&gt; sumPt evtProb
&lt;interactive&gt;:1:1: error:
• No instance for (Show (Prob m0 Double))
    arising from a use of ‘print’
• In a stmt of an interactive GHCi command: print it</code></pre>
<p>Woops! Something's not right here... what's going on? Well, to answer that question, let's look at the type of <code class="sourceCode haskell">sumPt evtProb</code>.</p>
<pre><code>HEPExample&gt; :t sumPt evtProb
sumPt evtProb :: PrimMonad m =&gt; Prob m Double</code></pre>
<p>We're getting back a probability distribution over all possible <code class="sourceCode haskell"><span class="dt">Double</span></code>s, which is what we want...but how does one print such a thing? That's a great question, and one which apparently the compiler can't answer! One thing we can do <em>for sure</em>, though, is sample this distribution:</p>
<pre><code>HEPExample&gt; withSystemRandom . asGenIO . samples 10 $ sumPt evtProb
[94.11359301538116,84.77993589158864,92.82674080235154,61.9462895476663,92.13224164142169,88.92614222298857,71.01504548041477,77.92693906507571,109.10381978490473,97.80981038489617]</code></pre>
<p>Now don't get confused by &quot;<code class="sourceCode haskell">withSystemRandom <span class="fu">.</span> asGenIO <span class="fu">.</span> samples <span class="dv">10</span> <span class="fu">$</span></code>&quot;; that is simply saying, &quot;please sample the following distribution ten times with the system random number generator.&quot; What comes back is, of course, the interesting bit: ten samples of the <code class="sourceCode haskell">sumPt</code> distribution given the distributions of the lepton pts. Pretty slick, huh?</p>
<p>Of course in practice, our event data types and analysis procedures are much more complicated than <code class="sourceCode haskell"><span class="dt">Event</span></code> and <code class="sourceCode haskell">sumPt</code>. Thankfully this is in no way a problem.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evtInvM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Alternative</span> m) <span class="ot">=&gt;</span> <span class="dt">Event</span> m <span class="ot">-&gt;</span> m <span class="dt">Double</span>
evtInvM evt <span class="fu">=</span> <span class="kw">do</span>
  es <span class="ot">&lt;-</span> electrons evt    <span class="co">-- get electrons</span>
  guard <span class="fu">$</span> length es <span class="fu">==</span> <span class="dv">1</span> <span class="co">-- require exactly 1 electron</span>

  ms <span class="ot">&lt;-</span> muons evt        <span class="co">-- get muons</span>
  guard <span class="fu">$</span> length ms <span class="fu">==</span> <span class="dv">1</span> <span class="co">-- require exactly 1 muon</span>

  js <span class="ot">&lt;-</span> jets evt         <span class="co">-- get jets</span>
  guard <span class="fu">$</span> length js <span class="fu">==</span> <span class="dv">2</span> <span class="co">-- require exactly 2 jets</span>

  return <span class="fu">.</span> invM <span class="fu">.</span> mconcat <span class="fu">$</span> js <span class="fu">++</span> es <span class="fu">++</span> ms</code></pre></div>
<p>The above code checks for exactly one electron, one muon, two jets, then calculates the invariant mass of these objects. Any scale factors, systematic variations, or possible failure of cuts can be automatically propagated through the code just by using an appropriate <em>context</em>! I want to stress here that the type signature of <code class="sourceCode haskell">evtInvM</code> already encodes all of this information: it says you need a composable context (<code class="sourceCode haskell"><span class="dt">Monad</span></code>) that supports the possibility of failure (<code class="sourceCode haskell"><span class="dt">Alternative</span></code>); as long as you have these, then you can use this function.</p>
<p>Whew. I think that's enough for today. Hopefully I've given you a taste of what can be achieved with these very powerful abstractions that mathematicians have known about for years, but which only recently have seen use in much &quot;day-to-day&quot; code. Indeed, many more common idioms fit in the &quot;composable context&quot; box, including another ubiquitous one in HEP: systematic variations of values. In fact, so-called &quot;stacks&quot; of these contexts quite often follow the required rules, so you can construct a combined context that handles scale factors and the possibility of failure at the same time. And really this is just the tip of the iceberg: there are many more interesting, <em>rigorous</em> mathematical concepts at our disposal that already exist and are just waiting for us to use them in analyses, and by using these concepts we can make our analysis procedures easier to understand, easier to refactor, and generally more bug-free!</p>
</body>
</html>
